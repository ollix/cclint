# -*- coding: utf-8 -*-
#
# Copyright (c) 2015 Olli Wang. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
#    * Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#    * Redistributions in binary form must reproduce the above
# copyright notice, this list of conditions and the following disclaimer
# in the documentation and/or other materials provided with the
# distribution.
#    * Neither the name of Olli Wang nor the names of its
# contributors may be used to endorse or promote products derived from
# this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

"""This module contains the stream class to process cpplint's output."""

from __future__ import print_function
import codecs
import sys

from cclint import utility


# The line indent for each output message that passed to `FileStream.write()`.
_FILE_STREAM_INITIAL_LINE_INDENT = 6

# The patterns to identify the warning messages from cpplint's output. Each
# pattern contains a tuple of two strings, the first indicates that if a
# cpplint's output starts with the defined string, the output is treated as
# a warning message. The second is the separator that text behind which will
# be printed in the next line of the filename.
_WARNING_PATTERNS = (('Skipping input', ':'),
                     ('Ignoring', ';'))


class FileStream(codecs.StreamReaderWriter):
    """The stream used to intercept and format ccplint's output.

    This class is designed to change the output generated by cpplint when
    processing files. More specifically, it formats the output emitted by
    the `cpplint.ProcessFile()` call. Here's an example of how to use this
    class:

        stream = FileStream(sys.stderr,
                            codecs.getreader('utf8'),
                            codecs.getwriter('utf8'),
                            'replace')
        for filename in filenames:
            stream.begin(filename)
            cpplint.ProcessFile(filename, cpplint_state.verbose_level)
            stream.end()
    """

    def __init__(self, *args, **kwargs):
        """Initialization."""
        codecs.StreamReaderWriter.__init__(self, *args, **kwargs)
        self.filename = ''
        self.error_counts = 0
        self.original_stderr = None
        self.previous_file_has_error = False
        self.processed_files = 0
        self.total_error_counts = 0

    def begin(self, filename):
        """Prepares for file processing.

        This method should be called before each `cpplint.ProcessFile()` call.
        By calling this method, all the upcoming output will be redirected to
        this instance until the `end()` method is called.

        Args:
            filename: the filename string that will be passed to
                `cpplint.ProcessFile()`.
        """
        self.filename = filename
        self.error_counts = 0
        self.original_stderr = sys.stderr
        sys.stderr = self

    def end(self):
        """Ends of a file processing.

        This method should be called after each `cpplint.ProcessFile()` call.
        """
        self.filename = ''
        sys.stderr = self.original_stderr

    def print_filename(self, line_indent, state_symbol, state_ansi_color_code,
                       message=None):
        """Prints the formatted filename on console.

        Args:
            line_indent: a integer indicating the line indent.
            state_symbol: a string of the state symbol put before the filename.
            state_ansi_color_code: a string of ANSI color code that will be
                applied to print the state symbol.
            message: an optional string that will be printed on the next line
                of the filename.
        """
        current_file_has_error = (state_symbol == '✗')
        if self.processed_files == 0 or \
           (self.previous_file_has_error and not current_file_has_error):
            print('')

        print(utility.get_ansi_code('FOREGROUND_RESET') + ' ' * line_indent +
              state_ansi_color_code + state_symbol + ' ' +
              utility.get_ansi_code('FOREGROUND_RESET') +
              utility.get_ansi_code('STYLE_NORMAL') + self.filename)
        if message:
            print(' ' * line_indent +
                  utility.get_ansi_code('FOREGROUND_CYAN') +
                  utility.get_ansi_code('STYLE_DIM') +
                  '  // {:}'.format(message) +
                  utility.get_ansi_code('STYLE_RESET_ALL'))

        self.processed_files += 1
        self.previous_file_has_error = current_file_has_error

    def write(self, output):
        """Formats the output message."""
        # Restores the output stream temporarily so interpreter trackback
        # can be displayed as usually.
        sys.stderr = self.original_stderr
        line_indent = _FILE_STREAM_INITIAL_LINE_INDENT

        # Exits when done processing a file.
        if output.startswith('Done'):
            if self.error_counts == 0:
                self.print_filename(line_indent, '✓',
                                    utility.get_ansi_code('FOREGROUND_GREEN'))
            sys.stderr = self
            return

        # Exits when receiving a warning message.
        for beginning_match, seprator in _WARNING_PATTERNS:
            if output.startswith(beginning_match):
                message = output.split(seprator, 1)[1].strip()
                message = message[0].lower() + message[1:]
                self.print_filename(line_indent, '⚠',
                                    utility.get_ansi_code('FOREGROUND_YELLOW'),
                                    message)
                sys.stderr = self
                return

        # Found an error. Increments the `error_counts`.
        self.error_counts += 1
        self.total_error_counts += 1

        if self.error_counts == 1:
            if self.processed_files > 0:
                print('')
            self.print_filename(line_indent, '✗',
                                utility.get_ansi_code('FOREGROUND_RED'))
        line_number, description = output.split(':', 2)[1:]
        line_indent += 2

        print(' ' * line_indent +
              utility.get_ansi_code('FOREGROUND_YELLOW') + '#' + line_number +
              utility.get_ansi_code('FOREGROUND_WHITE') + ': ' +
              utility.get_ansi_code('STYLE_DIM') + description.strip() +
              utility.get_ansi_code('STYLE_RESET_ALL'))

        # Reindirects the output stream to this instance so we can keep
        # intercepting the messages from Google's cpplint.
        sys.stderr = self
